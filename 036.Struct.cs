using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

struct Vector
{
    //int x = 0;      // 구조체는 멤버를 직접 초기화가 불가능하다.
    //int y = 0;      // 클래스는 멤버 직접 초기화 가능

    public int x;       // 구조체는 그냥 멤버에
    public int y;       // 값을 넣어주는게 더 좋을거 같다.

    public int X        // 프로퍼티도 정의 가능한데 정말 필요한거 아니면 정의 안해도 된다.
    {
        get { return x; }
        set { x = value; }
    }

    public int Y
    {
        get { return y; }
        set { y = value; }
    }

    //public Vector() { Console.WriteLine("Vector 디폴트 생성자"); }    // 구조체는 디폴트 생성자 정의 불가
    public Vector(int x, int y)     // 매개변수를 받는 생성자는 정의 가능
    {
        this.x = x;     // 프로퍼티를
        this.y = y;     // 호출하는 것이 아니다.
    }

    public override string ToString()
    {
        return "x : " + x + " y : " + y;
    }
}

namespace CPPPP
{
    class Struct
    {
        public static void Main()
        {
            Vector v1 = new Vector();   // new를 사용해서 인스턴스 생성, 단 힙이 아니라 스택에 인스턴스를 생성한다.
            v1.X = 10;          // new로 할당했기 때문에
            v1.Y = 20;          // 프로퍼티로 저장 가능
            Console.WriteLine(v1);

            Vector v2;      // 그냥 만들어도 인스턴스를 생성 가능.
            //Console.WriteLine(v2);      // new로 인스턴스를 만들지 않았으면 그냥은 사용할 수 없다.

            Vector v3;      // 그냥 만들면
            v3.x = 10;      // 프로퍼티가 아니라
            v3.y = 20;      // 직접 멤버에 값을 저장해야 한다.
            Console.WriteLine(v3);      // 그리고 값이 있으므로 값이 출력된다.

            Vector v4 = new Vector(10, 20);     // 할당하자마자 값을 저장할 수 있다.
            Console.WriteLine(v4);              // 물론 값도 출력이 된다.
        }
    }
}

// 7 ~ 37행
// class와 비슷한 struct를 구현했다.
// C#에서는 class가 참조형식이라서 힙영역에 생성이 되지만, 구조체는 값형식이므로 스택에 생성된다.
// C++은 구조체와 클래스가 거의 차이가 없으며, 그냥 사용하면 스택에, new로 할당하면 힙영역에 생성된다.
// C에서는 물론 클래스 개념이 없기 때문에 차이를 가질 수 없다.
//
// 9, 10행
// 구조체는 멤버에 직접 값을 초기화할 수 없다.
// 클래스는 멤버에 직접 값을 초기화할 수 있다.
//
// 12, 13행
// 구조체는 외부에서 값을 직접 전달해 주는 것이 좋을 듯.
//
// 15 ~ 24행
// 구조체도 프로퍼티를 정의하여 멤버에 값을 저장할 수 있다.
// 다만 가능하다면 멤버를 public으로 정의하여 직접 값을 전달해 주는 것이 유리할 수 있다.
// 구조체와 클래스의 차이를 잘 생각해서 정의하자.
//
// 26행
// 구조체는 디폴트생성자를 정의할 수 없다.
//
// 27 ~ 31행
// 구조체는 디폴트 생성자는 정의할 수 없지만 매개변수를 받는 생성자는 정의할 수 있다.

// 45 ~ 48행
// 클래스처럼 new를 사용하여 인스턴스를 생성할 수 있다.
// new를 이용하여 인스턴스를 생성하면 구조체 멤버의 값이 없을 때 자동으로 값을 0으로 정한다.
// 다만 주의할 것은 구조체는 new를 사용하여 인스턴스를 생성해도 스택에 생성된다.
// 클래스는 인스턴스를 생성하면 힙에 생성된다.
// 또한 구조체는 new를 사용하여 할당해야 프로퍼티를 사용할 수 있다.

// 50, 51행
// new를 사용하지 않아도 인스턴스를 생성할 수 있다.
// 다만 ToString을 오버라이딩해도 값을 출력할 수 없다.
// C#에서는 개발자가 값을 할당하지 않고 생성한 객체는 오류로 판단한다.
// 따라서 new를 사용하지 않고 인스턴스를 생성하면 생성자가 호출되지도 않고 멤버에 값이 없는 상태로 생성하므로 오류를 일으킨다.

// 53 ~ 56행
// 구조체를 new를 사용하여 인스턴스를 생성하지 않으면 프로퍼티를 사용할 수 없다.
// 그렇기 때문에 인스턴스의 멤버에 직접 값을 넣어야 한다.

// 58, 59행
// 구조체에 매개변수를 두개를 받는 생성자를 정의했으므로 값을 넣어서 new로 생성할 수 있다.

// 가장 중요한 것은 struct가 값형식이고 class가 참조형식이라는 것이다.
// struct가 값형식이므로 무슨 행동을 해도 스택에 쌓이며, 이는 곧 가비지 컬렉터에 먹이를 주지 않는다는 뜻이다.
// class는 참조형식이므로 힙영역에 생성하며, 가비지 컬렉터의 표적이 된다.
// 값형식이므로 C, C++에서 보았던 Call By Value문제가 발생할 수 있다.
// 주로 메소드의 매개변수가 값형식이고 변경값을 전달하지 않았을 때 발생한다.

// 유니티에서 사용하는 Vector3는 구조체로 구현이 되어있다.
// 이동을 구현하기 위해서 Vector3.position += new Vector(3.0f, 0, 0);처럼 새로운 위치를 계속 넘겨주는 방식을 취한다.
// new를 사용하더라도 스택에 생성하므로 가비지 컬렉터에 영향을 주지 않는다.